<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.ArrayDataProviderBehavior
   */
  vaadin.elements.grid.ArrayDataProviderBehavior = {

    properties: {

      /**
       * An array containing the items which will be stamped to the column template
       * instances.
       */
      items: Array

    },

    observers: [
      '_itemsChanged(items, items.*)'
    ],

    _itemsChanged: function(items, splices) {
      if (items === undefined || splices === undefined) {
        return;
      }

      this.size = (items || []).length;
      this.dataProvider = this.dataProvider || this._arrayDataProvider;
      this.clearCache();
    },

    _arrayDataProvider: function(opts, cb) {
      var items = (this.items || []).slice(0);

      if (this._checkPaths(this._filters, 'filtering', items)) {
        items = this._filter(items, this._filters);
      }

      this.size = items.length;

      if (opts.sortOrders.length && this._checkPaths(this._sorters, 'sorting', items)) {
        items = items.sort(this._multiSort.bind(this));
      }

      var start = opts.page * opts.pageSize;
      var end = start + opts.pageSize;
      var slice = items.slice(start, end);
      cb(slice, items.length);
    },

    /**
     * Check array of filters/sorters for paths validity, console.warn invalid items
     * @param {Array}  arrayToCheck The array of filters/sorters to check
     * @param {string} action       The name of action to include in warning (filtering, sorting)
     * @param {Array}  items
     */
    _checkPaths: function(arrayToCheck, action, items) {
      if (!items.length) {
        return false;
      }

      var result = true;

      for (var i in arrayToCheck) {
        var path = arrayToCheck[i].path;

        // skip simple paths
        if (!path || path.indexOf('.') === -1) {
          continue;
        }

        var parentProperty = path.replace(/\.[^\.]*$/, ''); // a.b.c -> a.b
        if (Polymer.Base.get(parentProperty, items[0]) === undefined) {
          console.warn(
            'Path "' + path + '" used for ' + action + ' does not exist in all of the items, ' + action + ' is disabled.'
          );
          result = false;
        }
      }

      return result;
    },

    _multiSort: function(a, b) {
      return this._sorters.map(function(sort) {
        if (sort.direction === 'asc') {
          return this._compare(Polymer.Base.get(sort.path, a), Polymer.Base.get(sort.path, b));
        } else if (sort.direction === 'desc') {
          return this._compare(Polymer.Base.get(sort.path, b), Polymer.Base.get(sort.path, a));
        }
        return 0;
      }, this).reduce(function firstNonZeroValue(p, n) {
        return p ? p : n;
      }, 0);
    },

    _normalizeEmptyValue: function(value) {
      if ([undefined, null].indexOf(value) >= 0) {
        return '';
      } else if (isNaN(value)) {
        return value.toString();
      } else {
        return value;
      }
    },

    _compare: function(a, b) {
      a = this._normalizeEmptyValue(a);
      b = this._normalizeEmptyValue(b);

      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    },

    _filter: function(items, filter) {
      if (filter.length === 0) {
        return items;
      }

      return Array.prototype.filter.call(items, function(item, index) {
        var filtered = true;
        for (var i = 0; i < filter.length; i++) {
          var value = Polymer.Base.get(filter[i].path, item);
          if (filter[i].filter.indexOf(undefined) > -1 || filter[i].filter.indexOf(null) > -1 || value === undefined || value === null) {
            filtered = false;
          } else {
            if (filter[i].type === 'text') {
              filtered = filtered && (value.toString().toLowerCase().indexOf(filter[i].filter[0].toString().toLowerCase()) > -1);
            } else if (filter[i].type === 'number') {
              if (!filter[i].filter[1]) {
                filter[i].filter[1] = Number.MAX_SAFE_INTEGER;// upper limit
              }
              if (!filter[i].filter[0]) {
                filter[i].filter[0] = Number.MIN_SAFE_INTEGER;// lower limit
              }
              filtered = filtered && (+value >= +filter[i].filter[0] && +value <= +filter[i].filter[1]);
            } else if (filter[i].type === 'date') {
              if (!filter[i].filter[1]) {
                filter[i].filter[1] = new Date(4133874600000);// upper limit
              }
              if (!filter[i].filter[0]) {
                filter[i].filter[0] = new Date(-2209008600000);// lower limit
              }
              filtered = filtered && (new Date(value).getTime() >= filter[i].filter[0].getTime() && new Date(value) <= filter[i].filter[1].getTime());
            } else if (filter[i].type === 'boolean') {
              filtered = filtered && (JSON.parse(filter[i].filter[0]) === JSON.parse(value));
            } else if (filter[i].type === 'list') {
              filtered = filtered && (filter[i].filter.indexOf(value) > -1);
            }
          }
        }
        return filtered;
      });
    }

  };
</script>
